<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <title>印章生成器</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
            background-color: #f5f5f5;
        }

        canvas {
            border: 1px solid #ccc;
            background-color: transparent;
            display: block;
            margin-top: 20px;
        }

        label {
            display: inline-block;
            margin: 6px 10px;
        }

        input {
            padding: 4px;
            font-size: 14px;
            width: 80px;
        }

        button {
            padding: 6px 12px;
            font-size: 14px;
            margin-top: 10px;
        }
    </style>
</head>

<body>

    <h2>印章生成器（属性可调）</h2>

    <label>印章文字: <input id="sealText" value="什么什么有限公司"></label>
    <label>字体大小: <input id="fontSize" type="number" value="48"></label>
    <label>字体粗细:
        <select id="fontWeight">
            <option value="normal">正常</option>
            <option value="bold" selected>加粗</option>
            <option value="bolder">更粗</option>
            <option value="lighter">更细</option>
            <option value="100">100</option>
            <option value="200">200</option>
            <option value="300">300</option>
            <option value="400">400</option>
            <option value="500">500</option>
            <option value="600">600</option>
            <option value="700">700</option>
            <option value="800">800</option>
            <option value="900">900</option>
        </select>
    </label>
    <label>字体类型:
        <select id="fontFamily">
            <!-- 中文字体（Windows 常见） -->
            <option value="SimSun" selected>宋体 (SimSun)</option>
            <option value="SimHei">黑体 (SimHei)</option>
            <option value="KaiTi">楷体 (KaiTi)</option>
            <option value="FangSong">仿宋 (FangSong)</option>
            <option value="Microsoft YaHei">微软雅黑 (Microsoft YaHei)</option>
            <option value="STSong">华文宋体 (STSong)</option>
            <option value="STHeiti">华文黑体 (STHeiti)</option>
            <option value="STKaiti">华文楷体 (STKaiti)</option>
            <option value="STFangsong">华文仿宋 (STFangsong)</option>

            <!-- macOS 常见字体 -->
            <option value="PingFang SC">苹方 (PingFang SC)</option>
            <option value="Hiragino Sans GB">冬青黑体 (Hiragino Sans GB)</option>

            <!-- Google 开源字体 -->
            <option value="Noto Sans SC">思源黑体 (Noto Sans SC)</option>
            <option value="Noto Serif SC">思源宋体 (Noto Serif SC)</option>

            <!-- 英文字体 -->
            <option value="Arial">Arial</option>
            <option value="Arial Black">Arial Black</option>
            <option value="Verdana">Verdana</option>
            <option value="Tahoma">Tahoma</option>
            <option value="Trebuchet MS">Trebuchet MS</option>
            <option value="Times New Roman">Times New Roman</option>
            <option value="Georgia">Georgia</option>
            <option value="Courier New">Courier New</option>
            <option value="Lucida Console">Lucida Console</option>
            <option value="Impact">Impact</option>
        </select>
    </label>
    <label>文字颜色: <input id="fontColor" type="color" value="#ff0000"></label>
    <label>文字半径: <input id="textRadius" type="number" value="120"></label>
    <br>
    <label>起始角度: <input id="startDeg" type="number" value="170"></label>
    <label>结束角度: <input id="endDeg" type="number" value="360"></label><br>
    <label>中心图案: <input id="centerChar" value="★"></label>
    <label>图案大小: <input id="starSize" type="number" value="130"></label><br>
    <label>圆线宽度: <input id="circleWidth" type="number" value="10"></label>
    <label>圆线颜色: <input id="circleColor" type="color" value="#ff0000"></label>
    <br>
    <label>开启下方小字: <input type="checkbox" id="enableSmallText" checked></label>
    <label>小字文字: <input id="smallText" value="123456789"></label>
    <!-- 可选保留手动做旧 -->
    <br>
    <button onclick="applyVintageMask()">做旧</button>
    <button onclick="applySoftWornMaskOnSeal()">遮盖</button>
    <button onclick="smear()">拖影</button>
    <span>➡️</span>
    <button onclick="one()">一键</button>

    <br><br>
    <button onclick="drawSeal()">生成</button>
    <button onclick="downloadSeal()">下载</button>
    <span>&nbsp;&nbsp;&nbsp;</span>
    <button onclick="openConfigModal('export')">导出配置</button>
    <button onclick="openConfigModal('import')">导入配置</button>

    <canvas id="sealCanvas" width="400" height="400"></canvas>

    <!-- 配置弹窗 -->
    <div id="configModal" style="
        display: none; position: fixed; top: 0; left: 0;
        width: 100%; height: 100%;
        background-color: rgba(0,0,0,0.5);
        justify-content: center; align-items: center;
    ">
        <div style="
        background: #fff; padding: 20px;
        border-radius: 10px; width: 400px;
        box-shadow: 0 0 10px rgba(0,0,0,0.3);
    ">
            <h3 id="modalTitle">配置</h3>
            <textarea id="configText" rows="10" style="width:100%;font-family:monospace;"></textarea>
            <br><br>
            <button id="confirmBtn">确定</button>
            <button onclick="closeConfigModal()">关闭</button>
        </div>
    </div>
    <!-- ✅ 轻量提示气泡 -->
    <div id="toast" style="
        position: fixed;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(0,0,0,0.8);
        color: #fff;
        padding: 10px 20px;
        border-radius: 8px;
        font-size: 16px;
        opacity: 0;
        transition: opacity 0.5s;
        z-index: 9999;
        pointer-events: none;
        ">
    </div>

    <script>
        function drawSeal() {
            const canvas = document.getElementById("sealCanvas");
            const ctx = canvas.getContext("2d");

            // 获取用户设置
            const sealText = document.getElementById("sealText").value.trim();
            const smallText = document.getElementById("smallText").value.trim();
            const fontSize = parseInt(document.getElementById("fontSize").value);
            const fontWeight = document.getElementById("fontWeight").value;
            const fontFamily = document.getElementById("fontFamily").value;
            const fontColor = document.getElementById("fontColor").value;
            const textRadius = parseInt(document.getElementById("textRadius").value);
            const startDeg = parseFloat(document.getElementById("startDeg").value);
            const endDeg = parseFloat(document.getElementById("endDeg").value);
            const centerChar = document.getElementById("centerChar").value;
            const starSize = parseInt(document.getElementById("starSize").value);
            const circleWidth = parseInt(document.getElementById("circleWidth").value);
            const circleColor = document.getElementById("circleColor").value;
            const enableSmallText = document.getElementById("enableSmallText").checked; // ✅ 获取是否勾选小字

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 160;  // 外圈半径
            const chars = sealText.split("");
            const textLength = chars.length;

            // 弧度换算
            const startAngle = startDeg * Math.PI / 180;
            const endAngle = endDeg * Math.PI / 180;
            const totalAngle = (endAngle + 2 * Math.PI - startAngle) % (2 * Math.PI);
            const angleStep = textLength > 1 ? totalAngle / (textLength - 1) : 0;

            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 画圆圈
            ctx.strokeStyle = circleColor;
            ctx.lineWidth = circleWidth;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.stroke();

            // 画中心图案
            ctx.fillStyle = fontColor;
            ctx.font = `bold ${starSize}px serif`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(centerChar, centerX, centerY);

            // 绘制弧形文字
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
            ctx.fillStyle = fontColor;

            for (let i = 0; i < textLength; i++) {
                const angle = (startAngle + i * angleStep) % (2 * Math.PI);
                const x = textRadius * Math.cos(angle);
                const y = textRadius * Math.sin(angle);

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle + Math.PI / 2); // ✅ 正立
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(chars[i], 0, 0);
                ctx.restore();
            }
            ctx.restore();
            // === 下方弧形小字 ===
            if (enableSmallText) {
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.font = `bold ${fontSize / 3}px SimSun`;
                ctx.fillStyle = fontColor;

                // const bottomText = "32312025-001";  // ✅ 建议使用独立的下方文字
                const bottomChars = smallText.split("");
                const bottomLength = bottomChars.length;

                // 控制弧度范围（越小越集中）
                const totalAngle2 = Math.PI * 0.5;  // 🔥 0.7π 代表 126° 弧长，可调节
                const startAngle2 = Math.PI + totalAngle2 + 450;  // 从圆下方右侧开始
                const angleStep2 = totalAngle2 / (bottomLength - 1);

                for (let i = 0; i < bottomLength; i++) {
                    const angle = startAngle2 - i * angleStep2;  // 🔄 注意这里是反方向
                    const x = (textRadius + 20) * Math.cos(angle);
                    const y = (textRadius + 20) * Math.sin(angle);

                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle + Math.PI / 2);
                    ctx.scale(-1, -1); // ✅ 翻转下方文字方向
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(bottomChars[i], 0, 0);
                    ctx.restore();
                }

                ctx.restore();
            }
        }

        function downloadSeal() {
            const canvas = document.getElementById("sealCanvas");
            const link = document.createElement("a");
            link.download = "seal.png";
            link.href = canvas.toDataURL("image/png");
            link.click();
        }

        //做旧
        function applyVintageMask() {
            const canvas = document.getElementById("sealCanvas");
            const ctx = canvas.getContext("2d");
            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;

            // 1. 轻度擦除破损遮罩（不规则渐隐圆形块）
            ctx.save();
            ctx.globalCompositeOperation = "destination-out";
            const maskCount = 20 + Math.floor(Math.random() * 15); // 遮罩数量 20~35，少量

            for (let i = 0; i < maskCount; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const r = Math.random() * 10 + 3; // 半径 3~13
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, r);
                gradient.addColorStop(0, "rgba(0,0,0,0.4)");
                gradient.addColorStop(1, "rgba(0,0,0,0)");

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, 2 * Math.PI);
                ctx.fill();
            }
            ctx.restore();

            // 2. 轻度噪点
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                if (Math.random() < 0.07) {
                    const noise = (Math.random() - 0.5) * 15;
                    data[i] = Math.min(255, Math.max(0, data[i] + noise));
                    data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + noise));
                    data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + noise));
                }
            }
            ctx.putImageData(imageData, 0, 0);

            // 3. 裂痕，只在印章部分画，颜色半透明且稍粗，带阴影
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            data = imageData.data;

            const crackCount = 5 + Math.floor(Math.random() * 5);
            ctx.save();
            ctx.lineCap = "round";
            ctx.shadowColor = 'rgba(150, 0, 0, 0.5)';
            ctx.shadowBlur = 1.5;

            function isSealPixel(x, y) {
                const idx = (y * canvas.width + x) * 4;
                const r = data[idx], g = data[idx + 1], b = data[idx + 2], a = data[idx + 3];
                return a > 50 && r > 100 && g < 100 && b < 100;
            }

            for (let i = 0; i < crackCount; i++) {
                let tries = 0, x, y;
                do {
                    x = Math.floor(Math.random() * canvas.width);
                    y = Math.floor(Math.random() * canvas.height);
                    tries++;
                } while (!isSealPixel(x, y) && tries < 100);

                if (tries >= 100) break;

                const segments = 10 + Math.floor(Math.random() * 8);

                ctx.beginPath();
                ctx.moveTo(x, y);

                for (let j = 0; j < segments; j++) {
                    let nx = x + Math.floor((Math.random() - 0.5) * 20);
                    let ny = y + Math.floor((Math.random() - 0.5) * 20);

                    nx = Math.min(canvas.width - 1, Math.max(0, nx));
                    ny = Math.min(canvas.height - 1, Math.max(0, ny));

                    if (!isSealPixel(nx, ny)) {
                        let found = false;
                        for (let dx = -4; dx <= 4; dx++) {
                            for (let dy = -4; dy <= 4; dy++) {
                                let tx = nx + dx, ty = ny + dy;
                                if (tx >= 0 && tx < canvas.width && ty >= 0 && ty < canvas.height) {
                                    if (isSealPixel(tx, ty)) {
                                        nx = tx;
                                        ny = ty;
                                        found = true;
                                        break;
                                    }
                                }
                            }
                            if (found) break;
                        }
                        if (!found) break;
                    }

                    ctx.lineTo(nx, ny);
                    x = nx;
                    y = ny;
                }

                ctx.strokeStyle = `rgba(150, 0, 0, ${0.15 + Math.random() * 0.15})`;
                ctx.lineWidth = 1.5 + Math.random() * 1.5;
                ctx.stroke();
            }
            ctx.restore();

            // 4. 淡化印章颜色，力度轻微
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            data = imageData.data;

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const idx = (y * canvas.width + x) * 4;

                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    const a = data[idx + 3];

                    const isSealColor = a > 50 && r > 100 && g < 100 && b < 100;
                    if (!isSealColor) continue;

                    const alpha = 0.1 + Math.random() * 0.3;
                    data[idx] = r + (255 - r) * alpha;
                    data[idx + 1] = g + (255 - g) * alpha;
                    data[idx + 2] = b + (255 - b) * alpha;
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }
        function applySoftWornMaskOnSeal() {
            const canvas = document.getElementById("sealCanvas");
            const ctx = canvas.getContext("2d");

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // 生成不规则遮盖形状位置（多边形）
            const wornCount = 4 + Math.floor(Math.random() * 6);

            // 先生成遮盖区域多边形数组
            const maskRegions = [];
            for (let i = 0; i < wornCount; i++) {
                const cx = Math.random() * canvas.width;
                const cy = Math.random() * canvas.height;
                const baseRadius = 30 + Math.random() * 40;
                const sides = 6 + Math.floor(Math.random() * 5);
                const points = [];

                for (let j = 0; j < sides; j++) {
                    const angle = (Math.PI * 2 / sides) * j + Math.random() * 0.3;
                    const radius = baseRadius * (0.7 + Math.random() * 0.6);
                    points.push([
                        cx + radius * Math.cos(angle),
                        cy + radius * Math.sin(angle)
                    ]);
                }

                maskRegions.push(points);
            }

            // 判断点是否在多边形内（射线法）
            function pointInPolygon(x, y, polygon) {
                let inside = false;
                for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                    const xi = polygon[i][0], yi = polygon[i][1];
                    const xj = polygon[j][0], yj = polygon[j][1];

                    const intersect = ((yi > y) != (yj > y))
                        && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            }

            // 对每个像素判断是否属于遮盖区域和印章区域
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const idx = (y * canvas.width + x) * 4;

                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    const a = data[idx + 3];

                    // 简单判断印章颜色范围（红色为主，非白色）
                    const isSealColor = a > 50 && r > 100 && g < 100 && b < 100;

                    if (!isSealColor) continue;

                    // 判断是否在遮盖区域
                    let inMask = false;
                    for (const polygon of maskRegions) {
                        if (pointInPolygon(x, y, polygon)) {
                            inMask = true;
                            break;
                        }
                    }

                    if (inMask) {
                        // 半透明白色遮盖 => 让颜色变淡
                        const alpha = 0.6 + Math.random() * 0.9; // 透明度随机
                        data[idx] = r + (255 - r) * alpha;
                        data[idx + 1] = g + (255 - g) * alpha;
                        data[idx + 2] = b + (255 - b) * alpha;
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }
        function smear() {
            const canvas = document.getElementById("sealCanvas");
            const ctx = canvas.getContext("2d");
            const w = canvas.width, h = canvas.height;

            const offCanvas = document.createElement("canvas");
            offCanvas.width = w;
            offCanvas.height = h;
            const offCtx = offCanvas.getContext("2d");
            offCtx.drawImage(canvas, 0, 0);

            ctx.clearRect(0, 0, w, h);

            const gridSize = 24;
            const maxRepeat = 3; // 最大拖影层数
            const baseAlpha = 0.2;

            // 为每个格子预先定义拖影因子
            const distortMap = {};
            for (let y = 0; y < h; y += gridSize) {
                for (let x = 0; x < w; x += gridSize) {
                    distortMap[`${x},${y}`] = {
                        distort: Math.random() < 0.25, // 25% 概率扭曲
                        intensity: Math.random(),      // 拖影强度因子（0~1）
                    };
                }
            }

            // ✅ 第一步：先绘制原图
            ctx.globalAlpha = 1;
            ctx.drawImage(offCanvas, 0, 0);

            // ✅ 第二步：根据每个格子的拖影强度重复绘制
            for (let repeat = 1; repeat <= maxRepeat; repeat++) {
                for (let y = 0; y < h; y += gridSize) {
                    for (let x = 0; x < w; x += gridSize) {
                        const cell = distortMap[`${x},${y}`];
                        if (!cell) continue;

                        const level = cell.intensity; // 拖影强度（影响透明度、偏移）

                        // 当前层是否绘制：弱的格子可能不绘制所有层
                        if (level < (repeat - 1) / maxRepeat) continue;

                        const alpha = baseAlpha * level * (1 - repeat / (maxRepeat + 1));
                        ctx.globalAlpha = alpha;

                        const globalOffsetX = (Math.random() - 0.5) * 2 * level;
                        const globalOffsetY = (Math.random() - 0.5) * 2 * level;

                        const doDistort = cell.distort;

                        if (doDistort) {
                            const offsetX = (Math.random() - 0.5) * 2;
                            const offsetY = (Math.random() - 0.5) * 2;
                            const scaleX = 1 + (Math.random() - 0.5) * 0.05;
                            const scaleY = 1 + (Math.random() - 0.5) * 0.05;
                            const angle = (Math.random() - 0.5) * 0.05;

                            ctx.save();
                            ctx.translate(x + gridSize / 2 + globalOffsetX + offsetX, y + gridSize / 2 + globalOffsetY + offsetY);
                            ctx.rotate(angle);
                            ctx.scale(scaleX, scaleY);
                            ctx.drawImage(offCanvas, x, y, gridSize, gridSize, -gridSize / 2, -gridSize / 2, gridSize, gridSize);
                            ctx.restore();
                        } else {
                            ctx.drawImage(offCanvas, x, y, gridSize, gridSize, x + globalOffsetX, y + globalOffsetY, gridSize, gridSize);
                        }
                    }
                }
            }

            ctx.globalAlpha = 1;
        }
        //一键
        function one() {
            applyVintageMask();
            applyVintageMask();
            applySoftWornMaskOnSeal();
            smear();
            smear();
        }

        //加载成功生成图案
        window.onload = drawSeal;

        /* 以下为配置的导出导入 */
        let currentMode = ""; // 记录当前模式（导出/导入）

        // 打开弹窗
        function openConfigModal(mode) {
            currentMode = mode; // 保存模式
            const modal = document.getElementById("configModal");
            const textArea = document.getElementById("configText");
            const title = document.getElementById("modalTitle");
            const confirmBtn = document.getElementById("confirmBtn");

            // 清空文本框
            textArea.value = "";

            if (mode === "export") {
                title.textContent = "导出配置";
                confirmBtn.textContent = "复制";
                // 获取当前配置并显示
                textArea.value = JSON.stringify(getConfig(), null, 2);
            } else {
                title.textContent = "导入配置";
                confirmBtn.textContent = "导入";
            }

            // 设置“确定”按钮行为
            confirmBtn.onclick = function () {
                if (mode === "export") {
                    // 导出模式：复制文本
                    textArea.select();
                    document.execCommand("copy");
                    showToast("✅ 配置已复制");
                } else {
                    // 导入模式：解析JSON并还原配置
                    try {
                        const cfg = JSON.parse(textArea.value);
                        setConfig(cfg);
                        showToast("✅ 配置已导入");
                        drawSeal();
                    } catch (e) {
                        alert("配置格式错误！");
                    }
                }
                closeConfigModal();
            };

            // 显示弹窗
            modal.style.display = "flex";
        }

        // 关闭弹窗
        function closeConfigModal() {
            document.getElementById("configModal").style.display = "none";
        }

        // 获取当前配置（用于导出）
        function getConfig() {
            return {
                sealText: document.getElementById("sealText").value.trim(),
                smallText: document.getElementById("smallText").value.trim(),
                fontSize: parseInt(document.getElementById("fontSize").value),
                fontWeight: document.getElementById("fontWeight").value,
                fontFamily: document.getElementById("fontFamily").value,
                fontColor: document.getElementById("fontColor").value,
                textRadius: parseInt(document.getElementById("textRadius").value),
                startDeg: parseFloat(document.getElementById("startDeg").value),
                endDeg: parseFloat(document.getElementById("endDeg").value),
                centerChar: document.getElementById("centerChar").value,
                starSize: parseInt(document.getElementById("starSize").value),
                circleWidth: parseInt(document.getElementById("circleWidth").value),
                circleColor: document.getElementById("circleColor").value,
                enableSmallText: document.getElementById("enableSmallText").checked
            };
        }

        // 设置配置（用于导入）
        function setConfig(cfg) {
            document.getElementById("sealText").value = cfg.sealText || "";
            document.getElementById("smallText").value = cfg.smallText || "";
            document.getElementById("fontSize").value = cfg.fontSize || 48;
            document.getElementById("fontWeight").value = cfg.fontWeight || "normal";
            document.getElementById("fontFamily").value = cfg.fontFamily || "SimSun";
            document.getElementById("fontColor").value = cfg.fontColor || "#000000";
            document.getElementById("textRadius").value = cfg.textRadius || 120;
            document.getElementById("startDeg").value = cfg.startDeg || 180;
            document.getElementById("endDeg").value = cfg.endDeg || 360;
            document.getElementById("centerChar").value = cfg.centerChar || "★";
            document.getElementById("starSize").value = cfg.starSize || 80;
            document.getElementById("circleWidth").value = cfg.circleWidth || 4;
            document.getElementById("circleColor").value = cfg.circleColor || "#000000";
            document.getElementById("enableSmallText").checked = cfg.enableSmallText || false;
        }
        // ✅ 页面提示气泡函数
        function showToast(message) {
            const toast = document.getElementById("toast");
            toast.textContent = message;       // 设置提示文字
            toast.style.opacity = "1";         // 显示
            setTimeout(() => {
                toast.style.opacity = "0";     // 淡出
            }, 1500); // 1.5 秒后消失
        }

    </script>

</body>

</html>