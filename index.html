<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <title>å°ç« ç”Ÿæˆå™¨</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
            background-color: #f5f5f5;
        }

        canvas {
            border: 1px solid #ccc;
            background-color: transparent;
            display: block;
            margin-top: 20px;
        }

        label {
            display: inline-block;
            margin: 6px 10px;
        }

        input {
            padding: 4px;
            font-size: 14px;
            width: 80px;
        }

        button {
            padding: 6px 12px;
            font-size: 14px;
            margin-top: 10px;
        }
    </style>
</head>

<body>

    <h2>å°ç« ç”Ÿæˆå™¨ï¼ˆå±æ€§å¯è°ƒï¼‰</h2>

    <label>å°ç« æ–‡å­—: <input id="sealText" value="ä»€ä¹ˆä»€ä¹ˆæœ‰é™å…¬å¸"></label>
    <label>å­—ä½“å¤§å°: <input id="fontSize" type="number" value="48"></label>
    <label>å­—ä½“ç²—ç»†:
        <select id="fontWeight">
            <option value="normal">æ­£å¸¸</option>
            <option value="bold" selected>åŠ ç²—</option>
            <option value="bolder">æ›´ç²—</option>
            <option value="lighter">æ›´ç»†</option>
            <option value="100">100</option>
            <option value="200">200</option>
            <option value="300">300</option>
            <option value="400">400</option>
            <option value="500">500</option>
            <option value="600">600</option>
            <option value="700">700</option>
            <option value="800">800</option>
            <option value="900">900</option>
        </select>
    </label>
    <label>å­—ä½“ç±»å‹:
        <select id="fontFamily">
            <!-- ä¸­æ–‡å­—ä½“ï¼ˆWindows å¸¸è§ï¼‰ -->
            <option value="SimSun" selected>å®‹ä½“ (SimSun)</option>
            <option value="SimHei">é»‘ä½“ (SimHei)</option>
            <option value="KaiTi">æ¥·ä½“ (KaiTi)</option>
            <option value="FangSong">ä»¿å®‹ (FangSong)</option>
            <option value="Microsoft YaHei">å¾®è½¯é›…é»‘ (Microsoft YaHei)</option>
            <option value="STSong">åæ–‡å®‹ä½“ (STSong)</option>
            <option value="STHeiti">åæ–‡é»‘ä½“ (STHeiti)</option>
            <option value="STKaiti">åæ–‡æ¥·ä½“ (STKaiti)</option>
            <option value="STFangsong">åæ–‡ä»¿å®‹ (STFangsong)</option>

            <!-- macOS å¸¸è§å­—ä½“ -->
            <option value="PingFang SC">è‹¹æ–¹ (PingFang SC)</option>
            <option value="Hiragino Sans GB">å†¬é’é»‘ä½“ (Hiragino Sans GB)</option>

            <!-- Google å¼€æºå­—ä½“ -->
            <option value="Noto Sans SC">æ€æºé»‘ä½“ (Noto Sans SC)</option>
            <option value="Noto Serif SC">æ€æºå®‹ä½“ (Noto Serif SC)</option>

            <!-- è‹±æ–‡å­—ä½“ -->
            <option value="Arial">Arial</option>
            <option value="Arial Black">Arial Black</option>
            <option value="Verdana">Verdana</option>
            <option value="Tahoma">Tahoma</option>
            <option value="Trebuchet MS">Trebuchet MS</option>
            <option value="Times New Roman">Times New Roman</option>
            <option value="Georgia">Georgia</option>
            <option value="Courier New">Courier New</option>
            <option value="Lucida Console">Lucida Console</option>
            <option value="Impact">Impact</option>
        </select>
    </label>
    <label>æ–‡å­—é¢œè‰²: <input id="fontColor" type="color" value="#ff0000"></label>
    <label>æ–‡å­—åŠå¾„: <input id="textRadius" type="number" value="120"></label>
    <br>
    <label>èµ·å§‹è§’åº¦: <input id="startDeg" type="number" value="170"></label>
    <label>ç»“æŸè§’åº¦: <input id="endDeg" type="number" value="360"></label><br>
    <label>ä¸­å¿ƒå›¾æ¡ˆ: <input id="centerChar" value="â˜…"></label>
    <label>å›¾æ¡ˆå¤§å°: <input id="starSize" type="number" value="130"></label><br>
    <label>åœ†çº¿å®½åº¦: <input id="circleWidth" type="number" value="10"></label>
    <label>åœ†çº¿é¢œè‰²: <input id="circleColor" type="color" value="#ff0000"></label>
    <br>
    <label>å¼€å¯ä¸‹æ–¹å°å­—: <input type="checkbox" id="enableSmallText" checked></label>
    <label>å°å­—æ–‡å­—: <input id="smallText" value="123456789"></label>
    <!-- å¯é€‰ä¿ç•™æ‰‹åŠ¨åšæ—§ -->
    <br>
    <button onclick="applyVintageMask()">åšæ—§</button>
    <button onclick="applySoftWornMaskOnSeal()">é®ç›–</button>
    <button onclick="smear()">æ‹–å½±</button>
    <span>â¡ï¸</span>
    <button onclick="one()">ä¸€é”®</button>

    <br><br>
    <button onclick="drawSeal()">ç”Ÿæˆ</button>
    <button onclick="downloadSeal()">ä¸‹è½½</button>
    <span>&nbsp;&nbsp;&nbsp;</span>
    <button onclick="openConfigModal('export')">å¯¼å‡ºé…ç½®</button>
    <button onclick="openConfigModal('import')">å¯¼å…¥é…ç½®</button>

    <canvas id="sealCanvas" width="400" height="400"></canvas>

    <!-- é…ç½®å¼¹çª— -->
    <div id="configModal" style="
        display: none; position: fixed; top: 0; left: 0;
        width: 100%; height: 100%;
        background-color: rgba(0,0,0,0.5);
        justify-content: center; align-items: center;
    ">
        <div style="
        background: #fff; padding: 20px;
        border-radius: 10px; width: 400px;
        box-shadow: 0 0 10px rgba(0,0,0,0.3);
    ">
            <h3 id="modalTitle">é…ç½®</h3>
            <textarea id="configText" rows="10" style="width:100%;font-family:monospace;"></textarea>
            <br><br>
            <button id="confirmBtn">ç¡®å®š</button>
            <button onclick="closeConfigModal()">å…³é—­</button>
        </div>
    </div>
    <!-- âœ… è½»é‡æç¤ºæ°”æ³¡ -->
    <div id="toast" style="
        position: fixed;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(0,0,0,0.8);
        color: #fff;
        padding: 10px 20px;
        border-radius: 8px;
        font-size: 16px;
        opacity: 0;
        transition: opacity 0.5s;
        z-index: 9999;
        pointer-events: none;
        ">
    </div>

    <script>
        function drawSeal() {
            const canvas = document.getElementById("sealCanvas");
            const ctx = canvas.getContext("2d");

            // è·å–ç”¨æˆ·è®¾ç½®
            const sealText = document.getElementById("sealText").value.trim();
            const smallText = document.getElementById("smallText").value.trim();
            const fontSize = parseInt(document.getElementById("fontSize").value);
            const fontWeight = document.getElementById("fontWeight").value;
            const fontFamily = document.getElementById("fontFamily").value;
            const fontColor = document.getElementById("fontColor").value;
            const textRadius = parseInt(document.getElementById("textRadius").value);
            const startDeg = parseFloat(document.getElementById("startDeg").value);
            const endDeg = parseFloat(document.getElementById("endDeg").value);
            const centerChar = document.getElementById("centerChar").value;
            const starSize = parseInt(document.getElementById("starSize").value);
            const circleWidth = parseInt(document.getElementById("circleWidth").value);
            const circleColor = document.getElementById("circleColor").value;
            const enableSmallText = document.getElementById("enableSmallText").checked; // âœ… è·å–æ˜¯å¦å‹¾é€‰å°å­—

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 160;  // å¤–åœˆåŠå¾„
            const chars = sealText.split("");
            const textLength = chars.length;

            // å¼§åº¦æ¢ç®—
            const startAngle = startDeg * Math.PI / 180;
            const endAngle = endDeg * Math.PI / 180;
            const totalAngle = (endAngle + 2 * Math.PI - startAngle) % (2 * Math.PI);
            const angleStep = textLength > 1 ? totalAngle / (textLength - 1) : 0;

            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ç”»åœ†åœˆ
            ctx.strokeStyle = circleColor;
            ctx.lineWidth = circleWidth;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.stroke();

            // ç”»ä¸­å¿ƒå›¾æ¡ˆ
            ctx.fillStyle = fontColor;
            ctx.font = `bold ${starSize}px serif`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(centerChar, centerX, centerY);

            // ç»˜åˆ¶å¼§å½¢æ–‡å­—
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
            ctx.fillStyle = fontColor;

            for (let i = 0; i < textLength; i++) {
                const angle = (startAngle + i * angleStep) % (2 * Math.PI);
                const x = textRadius * Math.cos(angle);
                const y = textRadius * Math.sin(angle);

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle + Math.PI / 2); // âœ… æ­£ç«‹
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(chars[i], 0, 0);
                ctx.restore();
            }
            ctx.restore();
            // === ä¸‹æ–¹å¼§å½¢å°å­— ===
            if (enableSmallText) {
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.font = `bold ${fontSize / 3}px SimSun`;
                ctx.fillStyle = fontColor;

                // const bottomText = "32312025-001";  // âœ… å»ºè®®ä½¿ç”¨ç‹¬ç«‹çš„ä¸‹æ–¹æ–‡å­—
                const bottomChars = smallText.split("");
                const bottomLength = bottomChars.length;

                // æ§åˆ¶å¼§åº¦èŒƒå›´ï¼ˆè¶Šå°è¶Šé›†ä¸­ï¼‰
                const totalAngle2 = Math.PI * 0.5;  // ğŸ”¥ 0.7Ï€ ä»£è¡¨ 126Â° å¼§é•¿ï¼Œå¯è°ƒèŠ‚
                const startAngle2 = Math.PI + totalAngle2 + 450;  // ä»åœ†ä¸‹æ–¹å³ä¾§å¼€å§‹
                const angleStep2 = totalAngle2 / (bottomLength - 1);

                for (let i = 0; i < bottomLength; i++) {
                    const angle = startAngle2 - i * angleStep2;  // ğŸ”„ æ³¨æ„è¿™é‡Œæ˜¯åæ–¹å‘
                    const x = (textRadius + 20) * Math.cos(angle);
                    const y = (textRadius + 20) * Math.sin(angle);

                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle + Math.PI / 2);
                    ctx.scale(-1, -1); // âœ… ç¿»è½¬ä¸‹æ–¹æ–‡å­—æ–¹å‘
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(bottomChars[i], 0, 0);
                    ctx.restore();
                }

                ctx.restore();
            }
        }

        function downloadSeal() {
            const canvas = document.getElementById("sealCanvas");
            const link = document.createElement("a");
            link.download = "seal.png";
            link.href = canvas.toDataURL("image/png");
            link.click();
        }

        //åšæ—§
        function applyVintageMask() {
            const canvas = document.getElementById("sealCanvas");
            const ctx = canvas.getContext("2d");
            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;

            // 1. è½»åº¦æ“¦é™¤ç ´æŸé®ç½©ï¼ˆä¸è§„åˆ™æ¸éšåœ†å½¢å—ï¼‰
            ctx.save();
            ctx.globalCompositeOperation = "destination-out";
            const maskCount = 20 + Math.floor(Math.random() * 15); // é®ç½©æ•°é‡ 20~35ï¼Œå°‘é‡

            for (let i = 0; i < maskCount; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const r = Math.random() * 10 + 3; // åŠå¾„ 3~13
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, r);
                gradient.addColorStop(0, "rgba(0,0,0,0.4)");
                gradient.addColorStop(1, "rgba(0,0,0,0)");

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, 2 * Math.PI);
                ctx.fill();
            }
            ctx.restore();

            // 2. è½»åº¦å™ªç‚¹
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                if (Math.random() < 0.07) {
                    const noise = (Math.random() - 0.5) * 15;
                    data[i] = Math.min(255, Math.max(0, data[i] + noise));
                    data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + noise));
                    data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + noise));
                }
            }
            ctx.putImageData(imageData, 0, 0);

            // 3. è£‚ç—•ï¼Œåªåœ¨å°ç« éƒ¨åˆ†ç”»ï¼Œé¢œè‰²åŠé€æ˜ä¸”ç¨ç²—ï¼Œå¸¦é˜´å½±
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            data = imageData.data;

            const crackCount = 5 + Math.floor(Math.random() * 5);
            ctx.save();
            ctx.lineCap = "round";
            ctx.shadowColor = 'rgba(150, 0, 0, 0.5)';
            ctx.shadowBlur = 1.5;

            function isSealPixel(x, y) {
                const idx = (y * canvas.width + x) * 4;
                const r = data[idx], g = data[idx + 1], b = data[idx + 2], a = data[idx + 3];
                return a > 50 && r > 100 && g < 100 && b < 100;
            }

            for (let i = 0; i < crackCount; i++) {
                let tries = 0, x, y;
                do {
                    x = Math.floor(Math.random() * canvas.width);
                    y = Math.floor(Math.random() * canvas.height);
                    tries++;
                } while (!isSealPixel(x, y) && tries < 100);

                if (tries >= 100) break;

                const segments = 10 + Math.floor(Math.random() * 8);

                ctx.beginPath();
                ctx.moveTo(x, y);

                for (let j = 0; j < segments; j++) {
                    let nx = x + Math.floor((Math.random() - 0.5) * 20);
                    let ny = y + Math.floor((Math.random() - 0.5) * 20);

                    nx = Math.min(canvas.width - 1, Math.max(0, nx));
                    ny = Math.min(canvas.height - 1, Math.max(0, ny));

                    if (!isSealPixel(nx, ny)) {
                        let found = false;
                        for (let dx = -4; dx <= 4; dx++) {
                            for (let dy = -4; dy <= 4; dy++) {
                                let tx = nx + dx, ty = ny + dy;
                                if (tx >= 0 && tx < canvas.width && ty >= 0 && ty < canvas.height) {
                                    if (isSealPixel(tx, ty)) {
                                        nx = tx;
                                        ny = ty;
                                        found = true;
                                        break;
                                    }
                                }
                            }
                            if (found) break;
                        }
                        if (!found) break;
                    }

                    ctx.lineTo(nx, ny);
                    x = nx;
                    y = ny;
                }

                ctx.strokeStyle = `rgba(150, 0, 0, ${0.15 + Math.random() * 0.15})`;
                ctx.lineWidth = 1.5 + Math.random() * 1.5;
                ctx.stroke();
            }
            ctx.restore();

            // 4. æ·¡åŒ–å°ç« é¢œè‰²ï¼ŒåŠ›åº¦è½»å¾®
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            data = imageData.data;

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const idx = (y * canvas.width + x) * 4;

                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    const a = data[idx + 3];

                    const isSealColor = a > 50 && r > 100 && g < 100 && b < 100;
                    if (!isSealColor) continue;

                    const alpha = 0.1 + Math.random() * 0.3;
                    data[idx] = r + (255 - r) * alpha;
                    data[idx + 1] = g + (255 - g) * alpha;
                    data[idx + 2] = b + (255 - b) * alpha;
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }
        function applySoftWornMaskOnSeal() {
            const canvas = document.getElementById("sealCanvas");
            const ctx = canvas.getContext("2d");

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // ç”Ÿæˆä¸è§„åˆ™é®ç›–å½¢çŠ¶ä½ç½®ï¼ˆå¤šè¾¹å½¢ï¼‰
            const wornCount = 4 + Math.floor(Math.random() * 6);

            // å…ˆç”Ÿæˆé®ç›–åŒºåŸŸå¤šè¾¹å½¢æ•°ç»„
            const maskRegions = [];
            for (let i = 0; i < wornCount; i++) {
                const cx = Math.random() * canvas.width;
                const cy = Math.random() * canvas.height;
                const baseRadius = 30 + Math.random() * 40;
                const sides = 6 + Math.floor(Math.random() * 5);
                const points = [];

                for (let j = 0; j < sides; j++) {
                    const angle = (Math.PI * 2 / sides) * j + Math.random() * 0.3;
                    const radius = baseRadius * (0.7 + Math.random() * 0.6);
                    points.push([
                        cx + radius * Math.cos(angle),
                        cy + radius * Math.sin(angle)
                    ]);
                }

                maskRegions.push(points);
            }

            // åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨å¤šè¾¹å½¢å†…ï¼ˆå°„çº¿æ³•ï¼‰
            function pointInPolygon(x, y, polygon) {
                let inside = false;
                for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                    const xi = polygon[i][0], yi = polygon[i][1];
                    const xj = polygon[j][0], yj = polygon[j][1];

                    const intersect = ((yi > y) != (yj > y))
                        && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            }

            // å¯¹æ¯ä¸ªåƒç´ åˆ¤æ–­æ˜¯å¦å±äºé®ç›–åŒºåŸŸå’Œå°ç« åŒºåŸŸ
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const idx = (y * canvas.width + x) * 4;

                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    const a = data[idx + 3];

                    // ç®€å•åˆ¤æ–­å°ç« é¢œè‰²èŒƒå›´ï¼ˆçº¢è‰²ä¸ºä¸»ï¼Œéç™½è‰²ï¼‰
                    const isSealColor = a > 50 && r > 100 && g < 100 && b < 100;

                    if (!isSealColor) continue;

                    // åˆ¤æ–­æ˜¯å¦åœ¨é®ç›–åŒºåŸŸ
                    let inMask = false;
                    for (const polygon of maskRegions) {
                        if (pointInPolygon(x, y, polygon)) {
                            inMask = true;
                            break;
                        }
                    }

                    if (inMask) {
                        // åŠé€æ˜ç™½è‰²é®ç›– => è®©é¢œè‰²å˜æ·¡
                        const alpha = 0.6 + Math.random() * 0.9; // é€æ˜åº¦éšæœº
                        data[idx] = r + (255 - r) * alpha;
                        data[idx + 1] = g + (255 - g) * alpha;
                        data[idx + 2] = b + (255 - b) * alpha;
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }
        function smear() {
            const canvas = document.getElementById("sealCanvas");
            const ctx = canvas.getContext("2d");
            const w = canvas.width, h = canvas.height;

            const offCanvas = document.createElement("canvas");
            offCanvas.width = w;
            offCanvas.height = h;
            const offCtx = offCanvas.getContext("2d");
            offCtx.drawImage(canvas, 0, 0);

            ctx.clearRect(0, 0, w, h);

            const gridSize = 24;
            const maxRepeat = 3; // æœ€å¤§æ‹–å½±å±‚æ•°
            const baseAlpha = 0.2;

            // ä¸ºæ¯ä¸ªæ ¼å­é¢„å…ˆå®šä¹‰æ‹–å½±å› å­
            const distortMap = {};
            for (let y = 0; y < h; y += gridSize) {
                for (let x = 0; x < w; x += gridSize) {
                    distortMap[`${x},${y}`] = {
                        distort: Math.random() < 0.25, // 25% æ¦‚ç‡æ‰­æ›²
                        intensity: Math.random(),      // æ‹–å½±å¼ºåº¦å› å­ï¼ˆ0~1ï¼‰
                    };
                }
            }

            // âœ… ç¬¬ä¸€æ­¥ï¼šå…ˆç»˜åˆ¶åŸå›¾
            ctx.globalAlpha = 1;
            ctx.drawImage(offCanvas, 0, 0);

            // âœ… ç¬¬äºŒæ­¥ï¼šæ ¹æ®æ¯ä¸ªæ ¼å­çš„æ‹–å½±å¼ºåº¦é‡å¤ç»˜åˆ¶
            for (let repeat = 1; repeat <= maxRepeat; repeat++) {
                for (let y = 0; y < h; y += gridSize) {
                    for (let x = 0; x < w; x += gridSize) {
                        const cell = distortMap[`${x},${y}`];
                        if (!cell) continue;

                        const level = cell.intensity; // æ‹–å½±å¼ºåº¦ï¼ˆå½±å“é€æ˜åº¦ã€åç§»ï¼‰

                        // å½“å‰å±‚æ˜¯å¦ç»˜åˆ¶ï¼šå¼±çš„æ ¼å­å¯èƒ½ä¸ç»˜åˆ¶æ‰€æœ‰å±‚
                        if (level < (repeat - 1) / maxRepeat) continue;

                        const alpha = baseAlpha * level * (1 - repeat / (maxRepeat + 1));
                        ctx.globalAlpha = alpha;

                        const globalOffsetX = (Math.random() - 0.5) * 2 * level;
                        const globalOffsetY = (Math.random() - 0.5) * 2 * level;

                        const doDistort = cell.distort;

                        if (doDistort) {
                            const offsetX = (Math.random() - 0.5) * 2;
                            const offsetY = (Math.random() - 0.5) * 2;
                            const scaleX = 1 + (Math.random() - 0.5) * 0.05;
                            const scaleY = 1 + (Math.random() - 0.5) * 0.05;
                            const angle = (Math.random() - 0.5) * 0.05;

                            ctx.save();
                            ctx.translate(x + gridSize / 2 + globalOffsetX + offsetX, y + gridSize / 2 + globalOffsetY + offsetY);
                            ctx.rotate(angle);
                            ctx.scale(scaleX, scaleY);
                            ctx.drawImage(offCanvas, x, y, gridSize, gridSize, -gridSize / 2, -gridSize / 2, gridSize, gridSize);
                            ctx.restore();
                        } else {
                            ctx.drawImage(offCanvas, x, y, gridSize, gridSize, x + globalOffsetX, y + globalOffsetY, gridSize, gridSize);
                        }
                    }
                }
            }

            ctx.globalAlpha = 1;
        }
        //ä¸€é”®
        function one() {
            applyVintageMask();
            applyVintageMask();
            applySoftWornMaskOnSeal();
            smear();
            smear();
        }

        //åŠ è½½æˆåŠŸç”Ÿæˆå›¾æ¡ˆ
        window.onload = drawSeal;

        /* ä»¥ä¸‹ä¸ºé…ç½®çš„å¯¼å‡ºå¯¼å…¥ */
        let currentMode = ""; // è®°å½•å½“å‰æ¨¡å¼ï¼ˆå¯¼å‡º/å¯¼å…¥ï¼‰

        // æ‰“å¼€å¼¹çª—
        function openConfigModal(mode) {
            currentMode = mode; // ä¿å­˜æ¨¡å¼
            const modal = document.getElementById("configModal");
            const textArea = document.getElementById("configText");
            const title = document.getElementById("modalTitle");
            const confirmBtn = document.getElementById("confirmBtn");

            // æ¸…ç©ºæ–‡æœ¬æ¡†
            textArea.value = "";

            if (mode === "export") {
                title.textContent = "å¯¼å‡ºé…ç½®";
                confirmBtn.textContent = "å¤åˆ¶";
                // è·å–å½“å‰é…ç½®å¹¶æ˜¾ç¤º
                textArea.value = JSON.stringify(getConfig(), null, 2);
            } else {
                title.textContent = "å¯¼å…¥é…ç½®";
                confirmBtn.textContent = "å¯¼å…¥";
            }

            // è®¾ç½®â€œç¡®å®šâ€æŒ‰é’®è¡Œä¸º
            confirmBtn.onclick = function () {
                if (mode === "export") {
                    // å¯¼å‡ºæ¨¡å¼ï¼šå¤åˆ¶æ–‡æœ¬
                    textArea.select();
                    document.execCommand("copy");
                    showToast("âœ… é…ç½®å·²å¤åˆ¶");
                } else {
                    // å¯¼å…¥æ¨¡å¼ï¼šè§£æJSONå¹¶è¿˜åŸé…ç½®
                    try {
                        const cfg = JSON.parse(textArea.value);
                        setConfig(cfg);
                        showToast("âœ… é…ç½®å·²å¯¼å…¥");
                        drawSeal();
                    } catch (e) {
                        alert("é…ç½®æ ¼å¼é”™è¯¯ï¼");
                    }
                }
                closeConfigModal();
            };

            // æ˜¾ç¤ºå¼¹çª—
            modal.style.display = "flex";
        }

        // å…³é—­å¼¹çª—
        function closeConfigModal() {
            document.getElementById("configModal").style.display = "none";
        }

        // è·å–å½“å‰é…ç½®ï¼ˆç”¨äºå¯¼å‡ºï¼‰
        function getConfig() {
            return {
                sealText: document.getElementById("sealText").value.trim(),
                smallText: document.getElementById("smallText").value.trim(),
                fontSize: parseInt(document.getElementById("fontSize").value),
                fontWeight: document.getElementById("fontWeight").value,
                fontFamily: document.getElementById("fontFamily").value,
                fontColor: document.getElementById("fontColor").value,
                textRadius: parseInt(document.getElementById("textRadius").value),
                startDeg: parseFloat(document.getElementById("startDeg").value),
                endDeg: parseFloat(document.getElementById("endDeg").value),
                centerChar: document.getElementById("centerChar").value,
                starSize: parseInt(document.getElementById("starSize").value),
                circleWidth: parseInt(document.getElementById("circleWidth").value),
                circleColor: document.getElementById("circleColor").value,
                enableSmallText: document.getElementById("enableSmallText").checked
            };
        }

        // è®¾ç½®é…ç½®ï¼ˆç”¨äºå¯¼å…¥ï¼‰
        function setConfig(cfg) {
            document.getElementById("sealText").value = cfg.sealText || "";
            document.getElementById("smallText").value = cfg.smallText || "";
            document.getElementById("fontSize").value = cfg.fontSize || 48;
            document.getElementById("fontWeight").value = cfg.fontWeight || "normal";
            document.getElementById("fontFamily").value = cfg.fontFamily || "SimSun";
            document.getElementById("fontColor").value = cfg.fontColor || "#000000";
            document.getElementById("textRadius").value = cfg.textRadius || 120;
            document.getElementById("startDeg").value = cfg.startDeg || 180;
            document.getElementById("endDeg").value = cfg.endDeg || 360;
            document.getElementById("centerChar").value = cfg.centerChar || "â˜…";
            document.getElementById("starSize").value = cfg.starSize || 80;
            document.getElementById("circleWidth").value = cfg.circleWidth || 4;
            document.getElementById("circleColor").value = cfg.circleColor || "#000000";
            document.getElementById("enableSmallText").checked = cfg.enableSmallText || false;
        }
        // âœ… é¡µé¢æç¤ºæ°”æ³¡å‡½æ•°
        function showToast(message) {
            const toast = document.getElementById("toast");
            toast.textContent = message;       // è®¾ç½®æç¤ºæ–‡å­—
            toast.style.opacity = "1";         // æ˜¾ç¤º
            setTimeout(() => {
                toast.style.opacity = "0";     // æ·¡å‡º
            }, 1500); // 1.5 ç§’åæ¶ˆå¤±
        }

    </script>

</body>

</html>